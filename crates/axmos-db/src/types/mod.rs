//! Types module.
use std::{
    error::Error,
    fmt::{Display, Formatter, Result as FmtResult},
    io::Error as IoError,
    str::Utf8Error,
};

use rkyv::rancor::Error as RkyvError;

pub(crate) mod core;
pub(crate) mod macros;

use axmos_derive::AutogeneratedDataType;

pub mod blob;
pub mod bool;
pub mod id;
pub mod numeric;
pub mod varint;

pub use blob::{Blob, BlobRef};
use bool::Bool;
use bytemuck::PodCastError;
pub use id::*;
pub use numeric::{Float32, Float64, Int32, Int64, UInt32, UInt64};
pub use varint::VarInt;

#[derive(Debug)]
pub enum SerializationError {
    InvalidVarIntPrefix,
    UnexpectedEof,
    BytemuckError(PodCastError),
    NotSupported,
    Io(IoError),
    Rkyv(RkyvError),

    Other(String),
}

impl Display for SerializationError {
    fn fmt(&self, f: &mut Formatter<'_>) -> FmtResult {
        match self {
            Self::InvalidVarIntPrefix => f.write_str("Incomplete or invalid VarInt prefix"),
            Self::UnexpectedEof => f.write_str("Unexpected EOF"),
            Self::BytemuckError(err) => write!(f, "Pod cast error: {err}"),
            Self::Io(err) => write!(f, "IO error {err}"),
            Self::NotSupported => f.write_str("Unsupported deserialization type"),
            Self::Rkyv(e) => write!(f, "Rkyv Error {e}"),
            Self::Other(string) => f.write_str(string),
        }
    }
}

impl From<PodCastError> for SerializationError {
    fn from(value: PodCastError) -> Self {
        Self::BytemuckError(value)
    }
}

impl From<RkyvError> for SerializationError {
    fn from(value: RkyvError) -> Self {
        Self::Rkyv(value)
    }
}

impl From<IoError> for SerializationError {
    fn from(value: IoError) -> Self {
        Self::Io(value)
    }
}

#[derive(Debug)]
pub enum TypeSystemError {
    Utf8Error(Utf8Error),

    SerializationError(SerializationError),
}

impl Error for TypeSystemError {}

impl Display for TypeSystemError {
    fn fmt(&self, f: &mut Formatter<'_>) -> FmtResult {
        match self {
            Self::Utf8Error(e) => write!(f, "Utf8 error: {e}"),
            Self::SerializationError(e) => write!(f, "Deserialization error: {e}"),
        }
    }
}
impl From<Utf8Error> for TypeSystemError {
    fn from(value: Utf8Error) -> Self {
        Self::Utf8Error(value)
    }
}

impl From<SerializationError> for TypeSystemError {
    fn from(value: SerializationError) -> Self {
        Self::SerializationError(value)
    }
}
pub type TypeSystemResult<T> = Result<T, TypeSystemError>;
pub type SerializationResult<T> = Result<T, SerializationError>;

#[derive(Debug, Clone, PartialEq, AutogeneratedDataType)]
#[delegate(
    trait = "crate::types::core::Hashable",
    method = "hash128",
    return_type = "u128",
    default = "0"
)]
#[delegate(
    trait = "crate::types::core::Hashable",
    method = "hash64",
    return_type = "u64",
    default = "0"
)]
#[delegate(
    trait = "crate::types::core::RuntimeSized",
    method = "runtime_size",
    return_type = "usize",
    default = "0"
)]
#[delegate(
    trait = "crate::types::core::TypeClass",
    const = "SIZE",
    target = "kind",
    as = "fixed_size",
    return_type = "Option<usize>",
    default = "None"
)]
#[delegate(
    trait = "crate::types::core::TypeClass",
    const = "ALIGN",
    target = "kind",
    as = "align",
    return_type = "usize",
    default = "1"
)]
#[delegate(
    trait = "crate::types::core::TypeClass",
    const = "ALIGN",
    target = "main",
    as = "align",
    return_type = "usize",
    default = "1"
)]
#[delegate(
    trait = "crate::types::core::SerializableType",
    method = "write_to",
    args = "&self, writer: &mut [u8], cursor: usize",
    target = "main",
    self_ref = "true",
    call_args = "inner, writer, cursor",
    return_type = "SerializationResult<usize>",
    default = "Err(SerializationError::NotSupported)"
)]
#[delegate(
    trait = "crate::types::core::DeserializableType",
    method = "reinterpret_cast",
    target = "kind",
    args = "self, buffer: &[u8]",
    call_args = "buffer",
    return_type = "SerializationResult<(DataTypeRef<'_>, usize)>",
    default = "Err(SerializationError::NotSupported)",
    wrap_result = "ref"
)]
#[ref_trait(
    ref_trait = "crate::types::core::RefTrait",
    assoc_type = "Ref",
    owned_trait = "crate::types::core::TypeRef<'a>"
)]

pub enum DataType {
    #[null]
    Null,
    Bool(Bool),
    Int(Int32),
    BigInt(Int64),
    UInt(UInt32),
    BigUInt(UInt64),
    Float(Float32),
    Double(Float64),
    Blob(Blob),
}
